# RaiBoard

A modular Raspberry Pi Pico game development and LoRa communication platform. *I had Copilot generate this readme for the benefit of new developers.*

---

## Table of Contents

- [Project Overview](#project-overview)
- [Directory Structure](#directory-structure)
- [Drivers Documentation](#drivers-documentation)
  - [C Drivers](#c-drivers)
  - [C++ Wrappers](#c-wrappers)
- [Build System (CMake)](#build-system-cmake)
- [Creating New Projects](#creating-new-projects)
- [Building and Deployment](#building-and-deployment)
- [Pico SDK Configuration](#pico-sdk-configuration)

---

## Project Overview

RaiBoard is built on the Raspberry Pi Pico platform and provides:

- **Low-level C drivers** for hardware interfacing (LoRa SX126x radio, ILI9341 TFT display)
- **C++ wrappers** for object-oriented access to the drivers
- **Modular architecture** to support multiple projects within a single repository
- **CMake-based build system** for easy project management

### Target Hardware

- **Microcontroller**: Raspberry Pi Pico (RP2040)
- **Pico SDK Version**: 2.2.0
- **Toolchain**: ARM GCC 14.2 Rel1

---

## Directory Structure

```
raiboard/
├── CMakeLists.txt              # Main project configuration (Pico SDK setup)
├── pico_sdk_import.cmake       # Pico SDK import helper
├── README.md                   # This file
├── .gitignore                  # Git ignore rules
├── .vscode/                    # VS Code configuration (settings, tasks, extensions)
├── build/                      # Build output directory (generated by CMake)
├── drivers/                    # Reusable drivers and wrappers
│   ├── CMakeLists.txt         # Drivers build configuration
│   ├── c_drivers/             # Low-level C drivers
│   │   ├── lora/              # LoRa radio driver (SX126x)
│   │   │   ├── lora_radio.h   # Bare-bones C driver interface
│   │   │   └── lora_radio.c   # Implementation
│   │   └── display/           # ILI9341 TFT display driver
│   │       ├── ili9341_display.h  # Bare-bones C driver interface
│   │       └── ili9341_display.c  # Implementation
│   └── cpp_wrappers/          # C++ wrappers around C drivers
│       ├── LoRa.hpp           # C++ LoRa class
│       ├── LoRa.cpp           # LoRa implementation
│       ├── Display.hpp        # C++ Display class
│       └── Display.cpp        # Display implementation
└── [your-projects]/           # Your application projects (to be added)
    ├── CMakeLists.txt         # Project-specific configuration
    └── main.c/main.cpp        # Project main file
```

---

## Drivers Documentation

### C Drivers

The C drivers provide bare-bones, low-level interfaces to hardware peripherals.

#### LoRa Radio Driver (`drivers/c_drivers/lora/lora_radio.h`)

**Purpose**: Interface with SX126x LoRa radio modules

**Key Features**:
- Frequency range: 150 MHz - 960 MHz (default: 915 MHz)
- Spreading Factors: SF5 - SF12 (default: SF12)
- Bandwidth options: 7.8 MHz - 500 MHz
- TX Power: 14 dBm (configurable)
- Max payload: 255 bytes
- Modes: IDLE, TX, RX, ERROR

**Default Configuration**:
```c
#define LORA_DEFAULT_FREQ_HZ            915000000
#define LORA_DEFAULT_TX_POWER           14
#define LORA_DEFAULT_SPREADING_FACTOR   12
#define LORA_MAX_PAYLOAD                255
```

**Example Usage (C)**:
```c
#include "lora_radio.h"

// Initialize LoRa with default config
lora_init_default();

// Transmit data
uint8_t data[] = {0xAA, 0xBB, 0xCC};
lora_transmit(data, 3);

// Receive data (interrupt-driven)
lora_set_rx_mode();
// RX interrupt handler will trigger when data arrives
```

**Hardware Requirements**:
- SPI communication to SX126x module
- GPIO pins for chip select, reset, and interrupt signals
- 3.3V power supply

---

#### Display Driver (`drivers/c_drivers/display/ili9341_display.h`)

**Purpose**: Interface with ILI9341 TFT display modules

**Key Features**:
- Resolution: 240×320 pixels
- 16-bit RGB565 color format
- 4 rotation modes (0°, 90°, 180°, 270°)
- Pre-defined color palette (16 colors)
- Buffer management: 240×320×2 = 153,600 bytes

**Pre-defined Colors**:
```c
COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE,
COLOR_CYAN, COLOR_MAGENTA, COLOR_YELLOW, COLOR_GRAY, COLOR_ORANGE,
COLOR_NAVY, COLOR_PURPLE
```

**Example Usage (C)**:
```c
#include "ili9341_display.h"

// Initialize display on GPIO pins 15(RST), 16(DC), 17(CS)
// with SPI0 at 25 MHz
display_init_default();

// Fill screen with color
display_fill_screen(COLOR_BLUE);

// Write string to display
display_write_string(0, 0, "Hello RaiBoard!", COLOR_WHITE, COLOR_BLUE);

// Rotate display
display_set_rotation(DISPLAY_ROTATION_90);
```

**Hardware Requirements**:
- SPI communication to ILI9341 module
- GPIO pins for reset (RST), data/command (DC), and chip select (CS)
- 3.3V power supply

---

### C++ Wrappers

C++ wrapper classes provide object-oriented interfaces to the C drivers with automatic resource management.

#### LoRa Class (`drivers/cpp_wrappers/LoRa.hpp`)

**Class Methods**:

```cpp
class LoRa {
public:
    // Constructor/Destructor
    LoRa();
    ~LoRa();
    
    // Initialization variants
    bool init();  // Default config
    bool init(uint32_t frequency_hz, lora_spreading_factor_t spreading_factor);
    bool init(const lora_config_t& config);  // Full config
    
    // Mode control
    void setIdleMode();
    void setRxMode();
    
    // Transmission
    bool transmit(const uint8_t* data, size_t length);
    bool transmitAsync(const uint8_t* data, size_t length);
    
    // Reception
    bool receiveBlocking(uint8_t* buffer, size_t& length, int16_t& rssi, int8_t& snr);
    void setRxCallback(RxCallback callback);
    
    // Configuration
    bool setFrequency(uint32_t frequency_hz);
    bool setSpreadingFactor(lora_spreading_factor_t sf);
    bool setBandwidth(lora_bandwidth_t bw);
    bool setTxPower(int8_t power_dbm);
    
    // Status
    lora_mode_t getMode();
    bool isTransmitting();
};
```

**Example Usage (C++)**:
```cpp
#include "LoRa.hpp"

int main() {
    LoRa radio;
    
    // Initialize with custom frequency and spreading factor
    if (!radio.init(915000000, LORA_SF_7)) {
        return -1;
    }
    
    // Set receive callback
    radio.setRxCallback([](const uint8_t* data, size_t len, int16_t rssi, int8_t snr) {
        // Handle received data
        printf("Received %d bytes, RSSI: %d, SNR: %d\n", len, rssi, snr);
    });
    
    // Start receiving
    radio.setRxMode();
    
    // Transmit data
    uint8_t message[] = {0x01, 0x02, 0x03};
    radio.transmit(message, sizeof(message));
    
    return 0;
}
```

**RxCallback Signature**:
```cpp
void callback(const uint8_t* data,  // Received data pointer
              size_t length,         // Data length in bytes
              int16_t rssi,         // Signal strength (-200 to 0 dBm)
              int8_t snr);          // Signal-to-noise ratio (-20 to 10 dB)
```

---

#### Display Class (`drivers/cpp_wrappers/Display.hpp`)

**Class Methods**:

```cpp
class Display {
public:
    // Constructor/Destructor
    Display();
    ~Display();
    
    // Initialization
    bool init(int8_t rst, int8_t dc, int8_t cs, int8_t sclk, int8_t mosi,
              int8_t miso, void* spi_inst, uint32_t spi_speed_hz);
    void deinit();
    
    // Drawing operations
    void fillScreen(uint16_t color);
    void drawPixel(uint16_t x, uint16_t y, uint16_t color);
    void drawLine(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t color);
    void drawRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
    void fillRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
    void drawCircle(uint16_t x, uint16_t y, uint16_t radius, uint16_t color);
    void fillCircle(uint16_t x, uint16_t y, uint16_t radius, uint16_t color);
    
    // Text operations
    void drawChar(uint16_t x, uint16_t y, char c, uint16_t fg, uint16_t bg);
    void drawString(uint16_t x, uint16_t y, const char* str, uint16_t fg, uint16_t bg);
    
    // Display control
    void setRotation(display_rotation_t rotation);
    void setBacklight(bool on);
    void sleep();
    void wake();
    
    // Buffer operations
    void writeBuffer(const uint8_t* buffer, size_t length);
    void readBuffer(uint8_t* buffer, size_t length);
};
```

**Example Usage (C++)**:
```cpp
#include "Display.hpp"

int main() {
    Display screen;
    
    // Initialize on SPI0, 25 MHz
    if (!screen.init(15, 16, 17, 18, 19, -1, spi0, 25000000)) {
        return -1;
    }
    
    // Fill screen
    screen.fillScreen(COLOR_BLACK);
    
    // Draw shapes and text
    screen.fillRectangle(10, 10, 100, 50, COLOR_BLUE);
    screen.drawCircle(120, 50, 25, COLOR_RED);
    screen.drawString(20, 200, "RaiBoard", COLOR_WHITE, COLOR_BLACK);
    
    // Rotate display
    screen.setRotation(DISPLAY_ROTATION_90);
    
    return 0;
}
```

---

## Build System (CMake)

### Understanding the CMake Structure

The project uses CMake to manage compilation. Here's how it works:

1. **Main CMakeLists.txt** (`/CMakeLists.txt`)
   - Sets up the Pico SDK
   - Adds subdirectories for drivers and projects
   - Configures C/C++ standards (C11, C++17)

2. **Drivers CMakeLists.txt** (`/drivers/CMakeLists.txt`)
   - Defines two C library targets: `pico_drivers_c_lora` and `pico_drivers_c_display`
   - Builds the C++ wrapper library: `pico_drivers_cpp`
   - Sets up include directories and dependencies
   - Forces C++17 standard for the wrapper library

### CMake Concepts Used

- **add_library()**: Creates a library target (used for drivers)
- **add_executable()**: Creates an executable (used for applications)
- **target_sources()**: Adds source files to a target
- **target_include_directories()**: Specifies header search paths
- **target_link_libraries()**: Links dependencies to a target
- **add_subdirectory()**: Includes another CMakeLists.txt file

---

## Creating New Projects

When you create a new project in the repository, you need to:

### Step 1: Create Project Directory

```bash
mkdir my_project
cd my_project
```

### Step 2: Create Project CMakeLists.txt

Create `my_project/CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.12)

# Define your executable
add_executable(my_app
    main.cpp
    # Add more source files here
)

# Link the drivers library
target_link_libraries(my_app
    pico_drivers_cpp  # To use C++ wrappers
    # OR use individual C drivers:
    # pico_drivers_c_lora
    # pico_drivers_c_display
    pico_stdlib
)

# Include driver headers (if using C drivers directly)
target_include_directories(my_app PRIVATE
    ${CMAKE_CURRENT_LIST_DIR}/../drivers/c_drivers/lora
    ${CMAKE_CURRENT_LIST_DIR}/../drivers/c_drivers/display
)

# Enable USB/UART output for debugging
pico_enable_stdio_usb(my_app 1)
pico_enable_stdio_uart(my_app 0)

# Create additional outputs (UF2 file for drag-and-drop programming)
pico_add_extra_outputs(my_app)
```

### Step 3: Create Application Code

Create `my_project/main.cpp`:

```cpp
#include "pico/stdlib.h"
#include "Display.hpp"
#include "LoRa.hpp"

int main() {
    stdio_init_all();
    
    // Initialize display
    Display screen;
    screen.init(15, 16, 17, 18, 19, -1, spi0, 25000000);
    screen.fillScreen(COLOR_BLACK);
    screen.drawString(50, 100, "RaiBoard!", COLOR_WHITE, COLOR_BLACK);
    
    // Initialize LoRa
    LoRa radio;
    radio.init();
    radio.setRxMode();
    
    // Your application logic here
    while (1) {
        tight_loop_contents();
    }
    
    return 0;
}
```

### Step 4: Update Main CMakeLists.txt

Edit the main `/CMakeLists.txt` and uncomment/add the subdirectory:

```cmake
# ... existing Pico SDK setup ...

# Add subdirectories for projects
add_subdirectory(drivers)
add_subdirectory(my_project)  # Add this line for your new project
# add_subdirectory(another_project)  # Additional projects

pico_sdk_init()
```

### Step 5: Rebuild

```bash
cd build
cmake ..
ninja
```

---

## Building and Deployment

### Visual Studio Code Tasks

The project includes pre-configured VS Code tasks for building and deployment:

1. **Compile Project**
   - Runs: `ninja -C build`
   - Builds all targets using Ninja build system
   - Shortcut: Usually Ctrl+Shift+B

2. **Run Project**
   - Executes: `picotool load [binary] -fx`
   - Loads and runs the binary on connected Pico
   - Requires USB connection to Pico

3. **Flash**
   - Uses OpenOCD to program via CMSIS-DAP debugger
   - Loads binary and verifies, then resets device
   - Requires CMSIS-DAP compatible debugger

4. **Rescue Reset**
   - Recovers Pico in failed state
   - Use if device doesn't respond

5. **RISC-V Reset (RP2350)**
   - For RP2350 only - resets RISC-V cores
   - Selects core architecture

### Manual Build Steps

```bash
# Navigate to workspace
cd /home/skgandre/raiboard

# Create/enter build directory
mkdir -p build && cd build

# Generate build files
cmake .. -GNinja

# Build with Ninja
ninja

# For specific target (if multiple projects)
ninja my_app

# Load onto Pico via USB
${HOME}/.pico-sdk/picotool/2.2.0-a4/picotool/picotool load build/my_project/my_app.uf2 -fx

# Or use OpenOCD for CMSIS-DAP debugging
${HOME}/.pico-sdk/openocd/0.12.0+dev/openocd.exe \
    -s ${HOME}/.pico-sdk/openocd/0.12.0+dev/scripts \
    -f interface/cmsis-dap.cfg \
    -f target/rp2040.cfg \
    -c "adapter speed 5000; program \"build/my_project/my_app.elf\" verify reset exit"
```

### Output Files Generated

After compilation, the `build/my_project/` directory contains:

- `my_app.elf` - Executable with debug symbols
- `my_app.uf2` - Binary for drag-and-drop loading onto Pico
- `my_app.bin` - Raw binary image
- `my_app.dis` - Disassembly (useful for debugging)

### Uploading to Pico

**Method 1: USB Drag-and-Drop (Easiest)**
1. Hold BOOTSEL button while plugging in Pico
2. Pico appears as mass storage device
3. Drag `my_app.uf2` to the Pico drive
4. Device resets and runs code

**Method 2: picotool via USB**
```bash
picotool load build/my_project/my_app.uf2 -fx
```

**Method 3: OpenOCD via CMSIS-DAP Debugger**
- Use for debugging with breakpoints
- See "Flash" task in VS Code

---

## Pico SDK Configuration

### Key Configuration Options (in CMakeLists.txt)

```cmake
# Set board type (pico, pico_w, pico2, pico2_w, pico_h)
set(PICO_BOARD pico CACHE STRING "Board type")

# C/C++ Standards
set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)

# Enable compilation database (for IDE support)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# For applications, you can control I/O:
pico_enable_stdio_usb(my_app 1)      # 1 = enabled, 0 = disabled
pico_enable_stdio_uart(my_app 0)     # 1 = enabled, 0 = disabled

# Generate extra output formats for various tools
pico_add_extra_outputs(my_app)       # Creates .elf, .uf2, .bin, .dis, .hex
```

### Standard Libraries Available

- `pico_stdlib` - Standard C library + Pico APIs
- `pico_time` - Time and timer functions
- `pico_sync` - Synchronization primitives (mutexes, semaphores)
- `hardware_gpio` - GPIO pin control
- `hardware_spi` - SPI interface
- `hardware_uart` - UART communication
- `hardware_i2c` - I2C interface
- Check Pico SDK documentation for more

---

## File Organization Best Practices

✅ **DO**:
- Keep each project in its own subdirectory
- Use separate CMakeLists.txt per project
- Link shared drivers via CMake targets
- Group related source files together
- Document hardware pin assignments at top of files

❌ **DON'T**:
- Put source code in the root directory
- Edit the build/ directory (it's regenerated)
- Mix multiple projects in one directory
- Commit build artifacts
- Hardcode GPIO pin numbers (use configuration structures)

---

## Troubleshooting

### CMake Build Fails
```bash
# Clean and rebuild
rm -rf build
mkdir build
cd build
cmake .. -GNinja
ninja
```

### "Could not find pico-sdk"
- Ensure `PICO_SDK_PATH` environment variable is set
- Check `pico_sdk_import.cmake` imports correctly

### Target Board Not Detected
- Install and configure Pico VS Code Extension
- Check board type in CMakeLists.txt matches your hardware

### Compilation Errors with Drivers
- Verify all GPIO pin numbers match your hardware
- Check SPI instance (spi0 vs spi1) is available
- Ensure drivers are properly linked in target_link_libraries

---

## Additional Resources

- [Pico SDK Documentation](https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf)
- [RP2040 Datasheet](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf)
- [CMake Documentation](https://cmake.org/cmake/help/latest/)
- [Ninja Build System](https://ninja-build.org/)

---

**Last Updated**: February 23, 2026  
**Project Author**: RaiLabs  
**Pico SDK Version**: 2.2.0
